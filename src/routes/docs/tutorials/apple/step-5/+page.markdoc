---
layout: tutorial
title: Manage navigation 
description: Add navigation to your SwiftUI app with Appwrite authentication.
step: 5
---

# Router {% #router %}

Routing is the process of navigating from one view to another, and SwiftUI makes use of the NavigationStack to allow us to control and manage how we push and pop views on the navigation stack. In order to define all our routes, specify the view for each route, and implement push and pop methods, we need to create a routing object. This code should be added to the `Router.swift` file located in the root folder.

```swift
import SwiftUI


enum Tabs {
    case home, progress, setting
}

enum Route {
    case appwrite
    case home
    case auth
    case add_habit
}

extension Route: View {
    var body: some View {
        switch self {
        case .appwrite:
             ContentView()
        case .home:
            HomeView()
        case .auth:
            AuthScreen()
        case .add_habit:
            AddHabitScreen()
        }
        
    }
}


extension Route: Hashable {
    static func == (lhs: Route, rhs: Route) -> Bool {
        return lhs.compareString == rhs.compareString
    }
    
    var compareString: String {
        switch self {
        case .appwrite:
            return "appwrite"
        case .home:
            return "home"
        case .auth:
            return "auth"
        case .add_habit:
            return "addHabit"
        }
    }
}


final class Router: ObservableObject {
    @Published var routes = [Route]()
    @Published var selectedTab: Tabs = .home
    
    func push(_ screen: Route) {
        routes.append(screen)
    }
    
    func pushReplacement(_ screen: Route) {
        if routes.isEmpty {
            routes.append(screen)
        } else {
            routes[routes.count - 1] = screen
        }
    }
    
    func pop() {
        routes.removeLast()
    }
    
    func popUntil(predicate: (Route) -> Bool) {
        if let last = routes.popLast() {
            guard predicate(last) else {
                popUntil(predicate: predicate)
                return
            }
        }
    }
    
    func reset() {
        routes = []
    }
}
```

# ContentView {% #contentview %}

Update the `ContentView.swift` to reflect some changes related to our navigation

```swift
import SwiftUI

struct ContentView: View {
    
    @EnvironmentObject private var router: Router
    @EnvironmentObject private var userViewModel: UserViewModel
    @EnvironmentObject private var snackBarService: SnackBarService
    @Environment(\.colorScheme) private var theme
    
    
    var body: some View {
        NavigationStack(path: $router.routes) {
            VStack {
                
                Image(theme == .dark ? "appwrite_light" : "appwrite_dark")
                    .frame(width: 132, height: 24)
                
            }
            .task {
                
                let isAuthenticated = await userViewModel.getCurrentSession()
                
                if !isAuthenticated {
                    router.pushReplacement(.auth)
                } else {
                    router.pushReplacement(.home)
                }
            }
            .navigationDestination(for: Route.self, destination: { $0 })
            
        }
        .overlay(alignment: .top) {
            if (snackBarService.snackBarState?.hasError == true) {
                SnackbarView(text: snackBarService.snackBarState?.error.localizedDescription ?? "An error occured")
            }
        }
        
    }
}
```

> Note: You can get the Appwrite logo on [Appwrite website](https://appwrite.io/assets/) and add it to your project assets

# Inject services and view models {% #inject-services-and-view-models %}

One of the important aspects of injecting services in SwiftUI with `@EnvironmentObject` is data sharing. This approach makes the service available and accessible in all your view components. Let's inject the Appwrite Service and Snackbar Service into our ViewModel, and then inject it into our app using `@EnvironmentObject`. Update the entry file with the following code.

```swift
import SwiftUI

@main
struct appwrite_hacktoberfestApp: App {
    
    private var appwriteService = AppwriteService()
    private var snackbarService = SnackBarService()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(Router())
                .environmentObject(UserViewModel(appwriteService, snackbarService))
                .environmentObject(HabitViewModel(appwriteService, snackbarService))
                .environmentObject(snackbarService)
        }
    }
}
```

Note: Change ``appwrite_hacktoberfestApp`` to your project name


## User view model {% #user-view-models %}

Add the following code to UserViewModel.swift inside `Home/ViewModels` folder.

```swift
import Foundation
import Appwrite

struct UserState {
    var userId: String? = nil
    var loading: Bool = false
    var isLogout: Bool = false
    
}

final class UserViewModel: ObservableObject {
    
    private var appwriteService: AppwriteService
    private var snackbarService: SnackBarService
    @Published var userState: UserState = UserState()
        
    init(_ appwriteService: AppwriteService, _ snackbarService: SnackBarService) {
        self.appwriteService = appwriteService
        self.snackbarService = snackbarService
    }
    
    @MainActor
    func getCurrentSession() async -> Bool {
        userState.loading = true
        defer { userState.loading = false }
        
        do {
            
            let res = try await appwriteService.currentSession()
            
            print(res)
            
            userState.userId = res.id
            userState.isLogout = false
            
            return true
            
        } catch {
            
            print(error)
            userState.isLogout = true
            
            return false
        }
        
    }
    
    @MainActor
    func login(_ email: String, _ password: String) async {
        
        do {
           let session = try await appwriteService.onLogin(email, password)
            
           print(session)
        } catch {
            
            snackbarService.displayError(error)
            
        }
        
    }
    
    @MainActor
    func register(_ email: String, _ password: String) async {
        
        do {
           let session = try await appwriteService.onRegister(email, password)
            
           print(session)
        } catch {
            
            snackbarService.displayError(error)
            
        }
        
    }
    
    @MainActor
    func logout() async {
        
        do {
           _ = try await appwriteService.onLogout()
        
        } catch {
            
            snackbarService.displayError(error)
            
        }
        
    }

    @MainActor
    func deleteAccount() async {
        
        do {
            _ = try await appwriteService.onAccountDelete()
        
        } catch {
            
            snackbarService.displayError(error)
            
        }
        
    } 
}
```

# Habit view model {% #habit-view-model %}

`HabitViewModel` class serves as the view model for handling Habit-related data and business logic in our app including fetch records, create new record, update record etc. Add the following code to `HabitViewModel.swift` inside `Home/ViewModels` folder.

```swift
import Appwrite
import Foundation


struct HabitState {
    var habits: [HabitModel] = []
    var gettingHabit: Bool = false
}

struct SelectedHabitState {
    var habit: HabitModel? = nil
    var isSelected: Bool = false
}


final class HabitViewModel: ObservableObject {
    
    private var appwriteService: AppwriteService
    private var snackbarService: SnackBarService
    @Published var habitState: HabitState = HabitState()
    @Published var selectedHabitState: SelectedHabitState = SelectedHabitState()
        
    init(_ appwriteService: AppwriteService, _ snackbarService: SnackBarService) {
        self.appwriteService = appwriteService
        self.snackbarService = snackbarService
    }
    
    
    @MainActor
    func fetchHabits() async {
        
        do {
            
            habitState.gettingHabit = true
            
            defer { habitState.gettingHabit = false }
            
            let data: DocumentList<HabitModel> = try await appwriteService.getDocs(.habit, .habits)
            
            habitState.habits = data.documents.map{ doc in
                
                HabitModel(id: doc.id, userId: doc.data.userId, title: doc.data.title, description: doc.data.description, goals: doc.data.goals, goalCompleted: doc.data.goalCompleted, icon: doc.data.icon, startDate: doc.data.startDate, endDate: doc.data.endDate)
                
            }
            
        } catch {
            
            snackbarService.displayError(error)
            
        }
        
    }
    
    
    
    @MainActor
    func create(_ title: String, _ description: String, _ goals: Int, _ icon: String, _ startDate: String, _ endDate: String, _ userId: String) async {
        
        do {
            
            try await appwriteService.insertDoc(
                .habit,
                .habits,
                data: [
                    "title": title,
                    "description": description,
                    "goals": goals,
                    "goalCompleted": 0,
                    "icon": icon,
                    "startDate": startDate,
                    "endDate": endDate,
                    "userId": userId
                ]
            )
            
        } catch {
            
            print(error)
            
            snackbarService.displayError(error)
            
        }
        
    }
    
    
    @MainActor
    func update(_ id: String, _ goalCompleted: Int) async {
        
        do {
            
            try await appwriteService.updateDoc(
                .habit,
                .habits,
                id,
                data: [
                    "goalCompleted": goalCompleted
                ]
            )
            
        } catch {
            
            print(error)
            
            snackbarService.displayError(error)
            
        }
        
    }
}
```